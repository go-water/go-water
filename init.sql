CREATE DATABASE  IF NOT EXISTS `go-water` /*!40100 DEFAULT CHARACTER SET utf8mb3 */ /*!80016 DEFAULT ENCRYPTION='N' */;
USE `go-water`;

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article` (
  `id` int NOT NULL AUTO_INCREMENT,
  `url_id` varchar(100) NOT NULL,
  `title` varchar(100) NOT NULL,
  `icon` varchar(200) NOT NULL,
  `kind` tinyint NOT NULL COMMENT '1：文档，2：技术',
  `visited` int NOT NULL DEFAULT '0',
  `brief` varchar(500) NOT NULL,
  `body` text NOT NULL,
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=43 DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (1,'why-go-water','为何要写 go-water 框架','/images/2023/2019011507005730.jpg',1,1,'go-water 灵感来之 go-kit，设计思路是工作总的积累提炼。','### 什么是 go-water\r\ngo-water 是一款设计层面的 web 框架（像 gin，iris，beego，echo 一样，追求卓越）。 我们使命：更好的业务隔离，更好的系统设计，通过一系列接口、规范、约定、中间件，深度解耦业务系统。\r\n\r\n### 为什么需要 go-water\r\n* 开源社区微服务治理的框架比较多，而 web 设计层面的框架基本没有见到，人们重视工具类框架，而忽视了设计类框架，但时作为一名优秀的架构师，不仅仅需要会使用各类工具，还得有优秀的设计能力。\r\n\r\n* 设计能力的提供主要依靠学习优秀的设计思想，看优秀的开源代码。当然自身对优雅的追求也是必不可少。\r\n* go-water 灵感来之 go-kit，设计思路源自工作中的总结。构思用了一年多时间，大多在睡觉前思考。思想成熟后一个月内完成框架的编码，陆陆续续修改一个月时间。\r\n* go-water 实现了物理的隔离每个接口，做到彻底的解耦系统，约定优雅，命名遵循约定，从而到达快速开发，快速定位问题。\r\n\r\n### go-water 适合哪些 web 框架\r\ngo-water 可以用于任何一个 web 框架，它没有强绑定任何一个框架，完成可以自由选择。','2023-02-16 15:37:56','2024-02-26 15:22:53'),(2,'which-web-frame-for-go-water','使用 go-water 写一个业务系统的必要代码','/images/2023/2019031908454483.png',1,4,'写个业务系统，麻雀虽小，五脏俱全。只要将代码安放到不同的目录，就可以无缝扩充你的业务系统。','这个样例，复制代码，就可以直接跑\r\n```\r\npackage main\r\n\r\nimport (\r\n	\"context\"\r\n	\"fmt\"\r\n	\"net/http\"\r\n	\"time\"\r\n\r\n	\"github.com/go-water/water\"\r\n	\"github.com/sony/gobreaker\"\r\n)\r\n\r\nfunc main() {\r\n	InitService()\r\n	router := water.New()\r\n	router.POST(\"/\", H.Index)\r\n	router.Serve(\":80\")\r\n}\r\n```\r\n控制层，这里定义了一个 Handlers 来管理所有业务接口\r\n```\r\n\r\nvar (\r\n	H *Handlers\r\n)\r\n\r\ntype Handlers struct {\r\n	index water.Handler\r\n}\r\n\r\nfunc NewService() *Handlers {\r\n	return &Handlers{\r\n		index: water.NewHandler(\r\n			&IndexService{ServerBase: &water.ServerBase{}})}\r\n}\r\n\r\nfunc InitService() {\r\n	H = NewService()\r\n}\r\n\r\nfunc (h *Handlers) Index(ctx *water.Context) {\r\n	request, err := water.BindJSON[IndexRequest](ctx)\r\n	if err != nil {\r\n		ctx.JSON(http.StatusBadRequest, water.H{\"err\": \"binding failure\"})\r\n		return\r\n	}\r\n	resp, err := h.index.ServerWater(ctx, request)\r\n	if err != nil {\r\n		ctx.JSON(http.StatusBadRequest, water.H{\"err\": \"service failure\"})\r\n		return\r\n	}\r\n\r\n	ctx.JSON(http.StatusOK, resp)\r\n}\r\n```\r\n业务服务层，业务接口服务结构体包含一个water.ServerBase，同时必须实现 Handle 方法\r\n```\r\ntype IndexService struct {\r\n	*water.ServerBase\r\n}\r\n\r\ntype IndexRequest struct {\r\n	Name string\r\n}\r\n\r\ntype IndexResponse struct {\r\n	Message string\r\n}\r\n\r\nfunc (s *IndexService) Handle(ctx context.Context, req *IndexRequest) (interface{}, error) {\r\n	resp := new(IndexResponse)\r\n	resp.Message = fmt.Sprintf(\"Hello, %s!\", req.Name)\r\n	return resp, nil\r\n}\r\n```\r\n运行结果\r\n```\r\n--request:\r\n{\r\n    \"Name\": \"Jimmy\"\r\n}\r\n--response:\r\n{\r\n    \"Message\": \"Hello, Jimmy!\"\r\n}\r\n```','2023-02-17 10:04:49','2024-03-12 15:17:04'),(3,'how-to-write-log-and-error','go-water 如何处理日志，错误','/images/2023/2018101506210421.jpg',1,7,'日志与错误的处理，一直是我重点考虑的事情，如何优雅的写日志，一直贯穿整个开发周期。','在服务中写日志\r\n```\r\nfunc (srv *IndexService) Handle(ctx context.Context, req *IndexRequest) (interface{}, error) {\r\n	srv.GetLogger().Info(\"流水日志记录\")\r\n	// 你的业务代码，省略\r\n	\r\n	return nil, nil\r\n}\r\n```\r\n\r\n在控制器中写日志\r\n```\r\nfunc (h *Handlers) Reward(ctx *water.Context) {\r\n	req := new(service.RewardRequest)\r\n	resp, err := h.reward.ServerWater(ctx, req)\r\n	if err != nil {\r\n		h.reward.GetLogger().Error(err.Error())\r\n		return\r\n	}\r\n\r\n	if result, ok := resp.([][]string); ok {\r\n		ctx.HTML(http.StatusOK, \"reward\", water.H{\"body\": result, \"title\": \"打赏站长\"})\r\n	}\r\n}\r\n```\r\n所有服务调用 error，在内部方法 ServerWater 都会写日志，并记录服务名，用户如果需要写流水日志可以如上调用。','2023-02-17 10:08:50','2024-04-02 17:40:59'),(4,'how-to-option-set','go-water 如何自定义配置','/images/2023/2019011507005731.jpg',1,19,'go-water 的配置参考 go-kit 与 go-micro 设计，都是通过 option 来设置自定义配置。','go-water 的配置参考 go-kit 与 go-micro 设计，使用 option 设置定义，所有定义的 option 都是作为 Service 服务的参数，见末尾使用方式\r\n\r\n### option 函数类型\r\n```\r\ntype ServerOption func(*Server)\r\n```\r\n\r\n### 自定义错误处理\r\n```\r\ntype ErrorHandler interface {\r\n	Handle(ctx context.Context, err error)\r\n}\r\n\r\nfunc ServerErrorHandler(errorHandler ErrorHandler) ServerOption {\r\n	return func(s *Server) { s.errorHandler = errorHandler }\r\n}\r\n```\r\n用例\r\n```\r\nerrorHandler := 一个实现 ErrorHandler 接口的结构体实例\r\noption := water.ServerErrorHandler(errorHandler)\r\n```\r\n可以自定义一个日志处理方式，比如写入磁盘\r\n\r\n### 后置执行器\r\n```\r\ntype ServerFinalizerFunc func(ctx context.Context, err error)\r\n\r\nfunc ServerFinalizer(f ...ServerFinalizerFunc) ServerOption {\r\n	return func(s *Server) { s.finalizer = append(s.finalizer, f...) }\r\n}\r\n```\r\n用例\r\n```\r\nfinalizerFunc := 一个 ServerFinalizerFunc 类型函数\r\noption := water.ServerFinalizer(finalizerFunc)\r\n```\r\n请求执行尾部需要执行的函数，可以理解为后置执行器\r\n\r\n### 限流\r\n```\r\nfunc ServerErrorLimiter(interval time.Duration, b int) ServerOption {\r\n	return func(s *Server) {\r\n		s.limit = rate.NewLimiter(rate.Every(interval), b)\r\n	}\r\n}\r\n```\r\n用例\r\n```\r\nfunc NewService() *Handlers {\r\n	option := water.ServerErrorLimiter(time.Minute, 100)\r\n	return &Handlers{\r\n		getArticle:  water.NewHandler(&service.GetArticleService{ServerBase: &water.ServerBase{}}, option),\r\n	}\r\n}\r\n```\r\n说明：每个 Handler 要实例一个 water.ServerBase，嵌套到 Service 服务里，不要共用一个实例。','2023-02-18 17:20:09','2024-04-09 10:38:22'),(5,'why-insert-into-server-base','业务结构体可以嵌套一个*water.ServerBase','/images/2023/2019012409594631.jpg',1,8,'嵌套一个结构体，主要是代码重用，减少重发代码，同时还可以注入值到框架层。','用例\r\n```\r\nreturn &Handlers{\r\n	index:       water.NewHandler(&service.IndexService{ServerBase: &water.ServerBase{}}, option),\r\n}\r\n```\r\n嵌套一个结构体，主要是代码重用，减少重复代码，同时还可以注入自定义 option 到框架层，更容易达到想要的效果','2023-02-18 17:23:40','2024-02-26 16:06:38'),(6,'use-middleware','中间件定义，使用','/images/2023/2019042908282963.jpg',1,4,'go-water 的中间件是HandlerFunc的一个封装','#### 定义\r\n`type Middleware func(HandlerFunc) HandlerFunc`\r\n#### 创建一个中间件，记录接口请求\r\n```\r\nfunc TraceApi(handlerFunc water.HandlerFunc) water.HandlerFunc {\r\n	return func(ctx *water.Context) {\r\n		start := time.Now()\r\n		defer func() {\r\n			msg := fmt.Sprintf(\"[WATER] %v | %15s | %13v | %-7s %s\",\r\n				time.Now().Format(\"2006/01/02 - 15:04:05\"),\r\n				ctx.ClientIP(),\r\n				time.Since(start),\r\n				ctx.Request.Method,\r\n				ctx.Request.URL.Path,\r\n			)\r\n\r\n			fmt.Println(msg)\r\n		}()\r\n\r\n		handlerFunc(ctx)\r\n	}\r\n}\r\n```\r\n使用中间件\r\n```\r\nrouter := water.New()\r\nrouter.Use(TraceApi)\r\n```\r\n#### 记录效果\r\n```\r\n[WATER] 2024/02/29 - 17:50:00 |             ::1 |     32.0409ms | GET     /doc/slog\r\n[WATER] 2024/02/29 - 17:50:01 |             ::1 |     29.7496ms | GET     /doc/circuit-breaker\r\n[WATER] 2024/02/29 - 17:50:01 |             ::1 |     29.0453ms | GET     /doc/rate-limit\r\n[WATER] 2024/02/29 - 17:50:02 |             ::1 |     28.2381ms | GET     /doc/upload-file\r\n[WATER] 2024/02/29 - 17:50:02 |             ::1 |     30.7071ms | GET     /doc/binging-validator\r\n[WATER] 2024/02/29 - 17:50:03 |             ::1 |     28.0768ms | GET     /doc/html-render\r\n[WATER] 2024/02/29 - 17:50:04 |             ::1 |     29.4973ms | GET     /doc/form-binding\r\n```','2023-02-23 10:16:20','2024-02-29 17:50:30'),(7,'jwt-auth','go-water 如何实现 jwt 登陆认证','/images/2023/2023022608282567.jpg',1,8,'go-water 使用通用的 jwt 做登录认证，更易兼容开源社区的组件，使用更加简单，方便。','### 创建token\r\n```\r\nfunc SetAuthToken(uniqueUser, privateKeyPath string, expire time.Duration) (tokenString string, err error)\r\n```\r\n输入参数\r\n+ uniqueUser，这个是用户标识符，可以用一个唯一的数字id，也可以是其他用户账号，但必须全局唯一\r\n+ privateKeyPath，秘钥的路径\r\n+ expire，超时时间\r\n\r\n输出参数\r\n+ tokenString，生成的token\r\n+ err，错误\r\n\r\n### 验证token\r\n```\r\nfunc ParseFromRequest(req *http.Request, publicKeyPath string) (uniqueUser, signature string, err error)\r\n```\r\n输入参数\r\n+ req，每个web框架都包含了这个对象\r\n+ publicKeyPath，公钥的路径\r\n\r\n输出参数\r\n+ uniqueUser，这个是用户标识符，对应于登陆输入参数uniqueUser\r\n+ signature，这个签名只包含jwt的最后一段字符串\r\n+ err，错误\r\n\r\n### 用法简介\r\n在用户登陆时，提交账号，密码，如果正确就调用 SetAuthToken 创建 token，将 token 发送给客户端，客户端保留 token，以便下次请求使用\r\n\r\n在验证阶段，用户将 token 信息包含在 header 中，通常使用关键字“Authorization”，如：Authorization: Bearer token，Bearer 和 token 之间有一个空格\r\n\r\n### 私钥，公钥生成\r\n```\r\n# 生成私钥\r\nopenssl genrsa -out rsa_private.key\r\n# 生成公钥\r\nopenssl rsa -in rsa_private.key -pubout -out rsa_public.key\r\n```\r\nopenssl命令一般linux系统都内置，可以直接用','2023-05-06 09:50:48','2023-11-16 10:17:46'),(35,'form-binding','Form表单绑定，用到泛型','-',1,0,'go-water 支持form表单绑定，反序列化后得到一个结构体，通过泛型获得类型。','定义一个请求参数的结构体，支持 form 格式\r\n```\r\ntype IndexRequest struct {\r\n	Name string `form:\"name\"`\r\n}\r\n```\r\n在控制器中如下使用即可获得 form 表单数据，使用了泛型类型\r\n```\r\nfunc Index(ctx *water.Context) {\r\n	request, err := water.BindJSON[IndexRequest](ctx)\r\n	......\r\n}\r\n```','2023-05-11 09:55:46','2024-04-12 11:51:12'),(36,'html-render','HTML 模板渲染','-',1,0,'go-water支持HTML 模板渲染。','```\r\npackage main\r\n\r\nimport (\r\n	\"fmt\"\r\n	\"net/http\"\r\n	\"time\"\r\n\r\n	\"github.com/go-water/water\"\r\n	\"github.com/go-water/water/multitemplate\"\r\n)\r\n\r\nfunc main() {\r\n	router := water.New()\r\n	router.HTMLRender = createMyRender()\r\n\r\n	router.Use(Logger)\r\n	router.GET(\"/\", Index)\r\n	v2 := router.Group(\"/v2\")\r\n	{\r\n		v2.GET(\"/hello\", GetHello)\r\n	}\r\n\r\n	router.Serve(\":80\")\r\n}\r\n\r\nfunc Index(ctx *water.Context) {\r\n	ctx.HTML(http.StatusOK, \"index\", water.H{\"title\": \"我是标题\", \"body\": \"你好，朋友。\"})\r\n}\r\n\r\nfunc GetHello(ctx *water.Context) {\r\n	ctx.JSON(http.StatusOK, water.H{\"msg\": \"Hello World!\"})\r\n}\r\n\r\nfunc Logger(handlerFunc water.HandlerFunc) water.HandlerFunc {\r\n	return func(ctx *water.Context) {\r\n		start := time.Now()\r\n		defer func() {\r\n			msg := fmt.Sprintf(\"[WATER] %v | %15s | %13v | %-7s %s\",\r\n				time.Now().Format(\"2006/01/02 - 15:04:05\"),\r\n				ctx.ClientIP(),\r\n				time.Since(start),\r\n				ctx.Request.Method,\r\n				ctx.Request.URL.Path,\r\n			)\r\n\r\n			fmt.Println(msg)\r\n		}()\r\n\r\n		handlerFunc(ctx)\r\n	}\r\n}\r\n\r\nfunc createMyRender() multitemplate.Renderer {\r\n	r := multitemplate.NewRenderer()\r\n	r.AddFromFiles(\"index\", \"views/layout.html\", \"views/index.html\", \"views/_header.html\", \"views/_footer.html\")\r\n	return r\r\n}\r\n```\r\nviews/layout.html\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"utf-8\" />\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n    <title>{{.title}}</title>\r\n</head>\r\n<body>\r\n<div>\r\n    <div>\r\n        {{template \"_header\"}}\r\n    </div>\r\n    <div>\r\n        {{template \"content\" .}}\r\n    </div>\r\n    <div>\r\n        {{template \"_footer\"}}\r\n    </div>\r\n</div>\r\n</body>\r\n</html>\r\n```\r\nviews/index.html\r\n```\r\n{{define \"content\"}}\r\n我是内容：{{.body}}\r\n{{end}}\r\n```\r\nviews/_header.html\r\n```\r\n{{define \"_header\"}}\r\n我是 Header。\r\n{{end}}\r\n```\r\nviews/_footer.html\r\n```\r\n{{define \"_footer\"}}\r\n我是 Footer。\r\n{{end}}\r\n```','2023-05-11 09:56:43','2024-03-12 17:28:49'),(37,'binging-validator','模型绑定时数据认证','-',1,0,'绑定数据时，对数据进行认证。','定义一个请求参数的结构体，对数据进行约束，最多5个字符，不可为空\r\n```\r\ntype IndexRequest struct {\r\n	Name string `form:\"name\" binding:\"required,max=5\"`\r\n}\r\n```\r\n在控制器中如下使用即可获得 form 表单数据，如果参数超过5个字符会报错\r\n```\r\nfunc Index(ctx *water.Context) {\r\n	request, err := water.BindJSON[IndexRequest](ctx)\r\n	......\r\n}\r\n```\r\n\r\n绑定数据时，对数据进行认证。与gin一样，使用 github.com/go-playground/validator ，用法相同。','2023-05-11 10:03:34','2024-03-12 15:30:50'),(38,'upload-file','文件上传','-',1,0,'go-water 支持文件上传。','表单\r\n```\r\n<input type=\"file\" name=\"file\" />\r\n```\r\n控制器\r\n```\r\nfunc (*Handlers) Upload(ctx *water.Context) {\r\n	file, err := ctx.FormFile(\"image\")\r\n	if err != nil {\r\n		ctx.JSON(http.StatusForbidden, err)\r\n		return\r\n	}\r\n\r\n	dir := \"/images/\" + time.Now().Format(\"20060102\") + \"/\"\r\n	err = os.MkdirAll(\"./public\"+dir, os.ModePerm)\r\n	if err != nil {\r\n		ctx.JSON(http.StatusForbidden, err)\r\n		return\r\n	}\r\n\r\n	url := dir + uuid.New().String() + strings.ToLower(path.Ext(file.Filename))\r\n	dst := \"./public/\" + url\r\n	err = ctx.SaveUploadedFile(file, dst)\r\n	if err != nil {\r\n		ctx.JSON(http.StatusForbidden, err)\r\n	}\r\n\r\n	ctx.JSON(http.StatusOK, water.H{\"filePath\": url})\r\n}\r\n```\r\nuuid，使用了 github.com/google/uuid 包','2024-02-26 14:16:26','2024-03-05 17:20:14'),(39,'rate-limit','rate limit 限流用例','-',1,0,'go-water支持限流。','只需在需要限流的接口对应的服务定义时添加，一分钟最多5次\r\n```\r\nwater.ServerLimiter(time.Minute, 5)\r\n```\r\n完整代码\r\n```\r\npackage main\r\n\r\nimport (\r\n	\"context\"\r\n	\"fmt\"\r\n	\"net/http\"\r\n	\"time\"\r\n\r\n	\"github.com/go-water/water\"\r\n)\r\n\r\nfunc main() {\r\n	InitService()\r\n	router := water.New()\r\n	router.POST(\"/\", H.Index)\r\n	router.Serve(\":80\")\r\n}\r\n\r\n// 控制层\r\nvar (\r\n	H *Handlers\r\n)\r\n\r\ntype Handlers struct {\r\n	index water.Handler\r\n}\r\n\r\nfunc NewService() *Handlers {\r\n	return &Handlers{\r\n		index: water.NewHandler(\r\n			&IndexService{ServerBase: &water.ServerBase{}},\r\n			water.ServerErrorLimiter(time.Minute, 5))}\r\n}\r\n\r\nfunc InitService() {\r\n	H = NewService()\r\n}\r\n\r\nfunc (h *Handlers) Index(ctx *water.Context) {\r\n	request, err := water.BindJSON[IndexRequest](ctx)\r\n	if err != nil {\r\n		ctx.JSON(http.StatusBadRequest, water.H{\"err\": \"binding failure\"})\r\n		return\r\n	}\r\n	resp, err := h.index.ServerWater(ctx, request)\r\n	if err != nil {\r\n		ctx.JSON(http.StatusBadRequest, water.H{\"err\": err.Error()})\r\n		return\r\n	}\r\n\r\n	ctx.JSON(http.StatusOK, resp)\r\n}\r\n\r\n// 业务服务层\r\ntype IndexService struct {\r\n	*water.ServerBase\r\n}\r\n\r\ntype IndexRequest struct {\r\n	Name string `form:\"name\"`\r\n}\r\n\r\ntype IndexResponse struct {\r\n	Message string\r\n}\r\n\r\nfunc (s *IndexService) Handle(ctx context.Context, req *IndexRequest) (interface{}, error) {\r\n	resp := new(IndexResponse)\r\n	resp.Message = fmt.Sprintf(\"Hello, %s!\", req.Name)\r\n	return resp, nil\r\n}\r\n```\r\n测试\r\n--request:\r\n```\r\n{\r\n    \"name\": \"Jimmy\"\r\n}\r\n--response:\r\n{\r\n    \"Message\": \"Hello, Jimmy!\"\r\n}\r\n--多请求几次就变成，按代码配置，请求6次就会返回如下\r\n{\r\n    \"err\": \"rate limit exceeded\"\r\n}\r\n```','2024-02-26 14:18:30','2024-04-09 10:37:25'),(40,'circuit-breaker','circuit breaker 熔断用例','-',1,0,'go-water 支持熔断。','只需在需要的接口对应的服务定义时添加\r\n```\r\nwater.ServerBreaker(gobreaker.NewCircuitBreaker(gobreaker.Settings{})))\r\n```\r\n完整代码\r\n```\r\npackage main\r\n\r\nimport (\r\n	\"context\"\r\n	\"io\"\r\n	\"net/http\"\r\n\r\n	\"github.com/go-water/water\"\r\n	\"github.com/sony/gobreaker\"\r\n)\r\n\r\nfunc main() {\r\n	InitService()\r\n	router := water.New()\r\n	router.POST(\"/\", H.Index)\r\n	router.Serve(\":80\")\r\n}\r\n\r\n// 控制层\r\nvar (\r\n	H *Handlers\r\n)\r\n\r\ntype Handlers struct {\r\n	index water.Handler\r\n}\r\n\r\nfunc NewService() *Handlers {\r\n	return &Handlers{\r\n		index: water.NewHandler(\r\n			&IndexService{ServerBase: &water.ServerBase{}},\r\n			water.ServerBreaker(gobreaker.NewCircuitBreaker(gobreaker.Settings{})))}\r\n}\r\n\r\nfunc InitService() {\r\n	H = NewService()\r\n}\r\n\r\nfunc (h *Handlers) Index(ctx *water.Context) {\r\n	request, err := water.BindJSON[IndexRequest](ctx)\r\n	if err != nil {\r\n		ctx.JSON(http.StatusBadRequest, water.H{\"err\": \"binding failure\"})\r\n		return\r\n	}\r\n	resp, err := h.index.ServerWater(ctx, request)\r\n	if err != nil {\r\n		ctx.JSON(http.StatusBadRequest, water.H{\"err\": err.Error()})\r\n		return\r\n	}\r\n\r\n	ctx.JSON(http.StatusOK, resp)\r\n}\r\n\r\n// 业务服务层\r\ntype IndexService struct {\r\n	*water.ServerBase\r\n}\r\n\r\ntype IndexRequest struct {\r\n	Url string `form:\"url\"`\r\n}\r\n\r\ntype IndexResponse struct {\r\n	Message string\r\n}\r\n\r\nfunc (s *IndexService) Handle(ctx context.Context, req *IndexRequest) (interface{}, error) {\r\n	result, err := http.Get(req.Url)\r\n	if err != nil {\r\n		return nil, err\r\n	}\r\n\r\n	bytes, _ := io.ReadAll(result.Body)\r\n\r\n	resp := &IndexResponse{\r\n		Message: string(bytes),\r\n	}\r\n\r\n	return resp, nil\r\n}\r\n```\r\n测试\r\n--request:\r\n```\r\n{\r\n    \"url\": \"http://go-water.cc\"\r\n}\r\n--response:\r\n{\r\n    \"err\": \"Get \\\"http://go-water.cc\\\": dial tcp: lookup go-water.cc: no such host\"\r\n}\r\n--多请求几次就变成\r\n{\r\n    \"err\": \"circuit breaker is open\"\r\n}\r\n```','2024-02-26 14:19:52','2024-03-12 16:14:37'),(41,'slog','log/slog 日志配置','-',1,0,'go-water 使用原生日志。','看看源码，使用原生日志 log/slog（go1.21 以及后续版本）\r\n```\r\npackage logger\r\n\r\nimport (\r\n	\"log/slog\"\r\n	\"os\"\r\n)\r\n\r\nvar (\r\n	Level     = slog.LevelInfo\r\n	AddSource bool\r\n)\r\n\r\nfunc NewLogger(level slog.Leveler, addSource bool) *slog.Logger {\r\n	return slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{Level: level, AddSource: addSource, ReplaceAttr: func(_ []string, a slog.Attr) slog.Attr {\r\n		v := a.Value\r\n		if v.Kind() == slog.KindTime {\r\n			return slog.String(a.Key, v.Time().Format(\"2006-01-02 15:04:05\"))\r\n		}\r\n\r\n		return a\r\n	}}))\r\n}\r\n```\r\n初始化 json 格式化日志，同时对时间格式化。\r\n```\r\nfunc (h *Handlers) Reward(ctx *water.Context) {\r\n	req := new(service.RewardRequest)\r\n	resp, err := h.reward.ServerWater(ctx, req)\r\n	if err != nil {\r\n		h.reward.GetLogger().Error(err.Error())\r\n		return\r\n	}\r\n\r\n	if result, ok := resp.([][]string); ok {\r\n		ctx.HTML(http.StatusOK, \"reward\", water.H{\"body\": result, \"title\": \"打赏站长\"})\r\n	}\r\n}\r\n```\r\n其中 h.reward.GetLogger() 就是 slog 实例','2024-02-26 15:27:36','2024-03-05 17:30:31'),(42,'openssl-public-private-key-pair','openssl 生成公/私钥对','',0,0,'使用openssl 生成公/私钥对。','### 私钥，公钥生成\r\n```\r\n# 生成私钥\r\nopenssl genrsa -out rsa_private.key\r\n# 生成公钥\r\nopenssl rsa -in rsa_private.key -pubout -out rsa_public.key\r\n```\r\nopenssl命令一般linux系统都内置，可以直接用','2024-02-26 17:59:19','2024-02-26 18:13:08');
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth`
--

DROP TABLE IF EXISTS `auth`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `auth` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user` varchar(30) NOT NULL,
  `password` varchar(16) NOT NULL,
  `created_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`,`user`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth`
--

LOCK TABLES `auth` WRITE;
/*!40000 ALTER TABLE `auth` DISABLE KEYS */;
INSERT INTO `auth` VALUES (1,'pinbor@x.com','123456','2023-05-08 11:40:42');
/*!40000 ALTER TABLE `auth` ENABLE KEYS */;
UNLOCK TABLES;